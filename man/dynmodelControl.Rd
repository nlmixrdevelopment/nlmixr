% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{dynmodelControl}
\alias{dynmodelControl}
\title{Control Options for dynmodel}
\usage{
dynmodelControl(..., fixPars = NULL, lower = -Inf, upper = Inf,
  method = c("bobyqa", "Nelder-Mead", "lbfgsb3c", "PORT"),
  ftol_rel = 1e-06, maxeval = 999, scaleTo = 1, scaleObjective = 0,
  normType = c("constant", "rescale2", "mean", "rescale", "std", "len"),
  scaleType = c("norm", "nlmixr", "mult", "multAdd"),
  scaleCmax = 1e+05, scaleCmin = 1e-05, scaleC = NULL,
  scaleC0 = 1e+05, atol = 1e-08, rtol = 1e-06, npt = NULL,
  rhobeg = 0.2, rhoend = 1e-04, iprint = 0, maxfun = NULL,
  trace = 0, factr = NULL, pgtol = NULL, abstol = NULL,
  reltol = NULL, lmm = NULL, maxit = NULL, eval.max = NULL,
  iter.max = NULL, abs.tol = NULL, rel.tol = NULL, x.tol = NULL,
  xf.tol = NULL, step.min = NULL, step.max = NULL, sing.tol = NULL,
  scale.init = NULL, diff.g = NULL)
}
\arguments{
\item{...}{other arguments apply to dynmodelControl}

\item{method}{The method for solving ODEs.  Currently this supports:

\itemize{
\item \code{"liblsoda"} thread safe lsoda.  This supports parallel
           thread-based solving, and ignores user Jacobian specification.
\item \code{"lsoda"} -- LSODA solver.  Does not support parallel thread-based
      solving, but allows user Jacobian specification.
\item \code{"dop853"} -- DOP853 solver.  Does not support parallel thread-based
        solving nor user Jacobain specification
}}

\item{scaleTo}{Scale the initial parameter estimate to this value.
By default this is 1.  When zero or below, no scaling is performed.}

\item{scaleObjective}{Scale the initial objective function to this
value.  By default this is 1.}

\item{normType}{This is the type of parameter
    normalization/scaling used to get the scaled initial valuse
    for nlmixr.  These are used with \code{scaleType} of.

    With the exception of \code{rescale2}, these come
    from
    \href{https://en.wikipedia.org/wiki/Feature_scaling}{Feature
    Scaling}. The \code{rescale2} The rescaling is the same type
    described in the
    \href{http://apmonitor.com/me575/uploads/Main/optimization_book.pdf}{OptdesX}
    software manual.

    In general, all all scaling formula can be described by:

    v_{scaled} = (v_{unscaled}-C_{1})/C_{2}

    Where


    The other data normalization approaches follow the following formula

    v_{scaled} = (v_{unscaled}-C_{1})/C_{2};

\itemize{

\item \code{rescale2} This scales all parameters from (-1 to 1).
    The relative differences between the parameters are preserved
    with this approach and the constants are:

    C_{1} = (max(all unscaled values)+min(all unscaled values))/2

    C_{2} = (max(all unscaled values) - min(all unscaled values))/2


\item \code{rescale} or min-max normalization. This rescales all
    parmeters from (0 to 1).  As in the \code{rescale2} the
    relative differences are preserved.  In this approach:

    C_{1} = min(all unscaled values)

    C_{2} = max(all unscaled values) - min(all unscaled values)


\item \code{mean} or mean normalization.  This rescales to center
    the parameters around the mean but the parameters are from 0
    to 1.  In this approach:

    C_{1} = mean(all unscaled values)

    C_{2} = max(all unscaled values) - min(all unscaled values)

\item \code{std} or standardization.  This standardizes by the mean
     and standard deviation.  In this approach:

    C_{1} = mean(all unscaled values)

    C_{2} = sd(all unscaled values)

\item \code{len} or unit length scaling.  This scales the
   parameters to the unit length.  For this approach we use the Euclidean length, that
   is:

    C_{1} = 0

    C_{2} = sqrt(v_1^2 + v_2^2 + ... + v_n^2)


\item \code{constant} which does not perform data normalization. That is

    C_{1} = 0

    C_{2} = 1

}}

\item{scaleType}{The scaling scheme for nlmixr.  The supported types are:

\itemize{
\item \code{nlmixr}  In this approach the scaling is performed by the following equation:

   v_{scaled} = (v_{current} - v_{init})/scaleC[i] + scaleTo

The \code{scaleTo} parameter is specified by the \code{normType},
and the scales are specified by \code{scaleC}.

\item \code{norm} This approach uses the simple scaling provided
    by the \code{normType} argument.

\item \code{mult} This approach does not use the data
normalization provided by \code{normType}, but rather uses
multiplicitve scaling to a constant provided by the \code{scaleTo}
argument.

  In this case:

  v_{scaled} = v_{current}/v_{init}*scaleTo

\item \code{multAdd} This approach changes the scaling based on
the parameter being specified.  If a parameter is defined in an
exponenital block (ie exp(theta)), then it is scaled on a
linearly, that is:

  v_{scaled} = (v_{current}-v_{init}) + scaleTo

Otherwise the parameter is scaled multiplicatively.

   v_{scaled} = v_{current}/v_{init}*scaleTo

}}

\item{scaleCmax}{Maximum value of the scaleC to prevent overflow.}

\item{scaleCmin}{Minimum value of the scaleC to prevent underflow.}

\item{scaleC}{The scaling constant used with
    \code{scaleType=nlmixr}.  When not specified, it is based on
    the type of parameter that is estimated.  The idea is to keep
    the derivatives similar on a log scale to have similar
    gradient sizes.  Hence parameters like log(exp(theta)) would
    have a scaling factor of 1 and log(theta) would have a scaling
    factor of ini_value (to scale by 1/value; ie
    d/dt(log(ini_value)) = 1/ini_value or scaleC=ini_value)

   \itemize{

   \item For parameters in an exponential (ie exp(theta)) or
   parameters specifying powers, boxCox or yeoJohnson
   transformations , this is 1.

   \item For additive, proportional, lognormal error structures,
   these are given by 0.5*abs(initial_estimate)

   \item Factorials are scaled by abs(1/digamma(inital_estimate+1))

   \item parameters in a log scale (ie log(theta)) are transformed
   by log(abs(initial_estimate))*abs(initial_estimate)

   }

   These parameter scaling coefficients are chose to try to keep
   similar slopes among parameters.  That is they all follow the
   slopes approximately on a log-scale.

   While these are chosen in a logical manner, they may not always
   apply.  You can specify each parameters scaling factor by this
   parameter if you wish.}

\item{scaleC0}{Number to adjust the scaling factor by if the initial
gradient is zero.}

\item{atol}{a numeric absolute tolerance (1e-8 by default) used
by the ODE solver to determine if a good solution has been
achieved;  This is also used in the solved linear model to check
if prior doses do not add anything to the solution.}

\item{rtol}{a numeric relative tolerance (1e-6 by default) used
by the ODE solver to determine if a good solution has been
achieved. This is also used in the solved linear model to check
 if prior doses do not add anything to the solution.}

\item{npt}{The number of points used to approximate the objective
function via a quadratic approximation for bobyqa. The value
of npt must be in the interval [n+2,(n+1)(n+2)/2] where n is
the number of parameters in par. Choices that exceed 2*n+1 are
not recommended. If not defined, it will be set to 2*n + 1}

\item{rhobeg}{Beginning change in parameters for bobyqa algorithm
(trust region).  By default this is 0.2 or 20% of the initial
parameters when the parameters are scaled to 1. rhobeg and
rhoend must be set to the initial and final values of a trust
region radius, so both must be positive with 0 < rhoend <
rhobeg. Typically rhobeg should be about one tenth of the
greatest expected change to a variable.  Note also that
smallest difference abs(upper-lower) should be greater than or
equal to rhobeg*2. If this is not the case then rhobeg will be
adjusted.}

\item{rhoend}{The smallest value of the trust region radius that
is allowed. If not defined, then 10^(-sigdig-1) will be used.}

\item{abstol}{Absolute tolerance for nlmixr optimizer}

\item{reltol}{tolerance for nlmixr}

\item{eval.max}{Number of maximum evaluations of the objective function}

\item{iter.max}{Maximum number of iterations allowed.}

\item{rel.tol}{Relative tolerance before nlminb stops.}

\item{x.tol}{X tolerance for nlmixr optimizers}
}
\description{
Control Options for dynmodel
}
